<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Book Flip Reader — Drag Fold</title>
  <style>
    :root{ --book-width:900px; --book-height:600px; }
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;display:flex;align-items:center;justify-content:center;min-height:100vh;margin:0;background:#f2f2f6}

    /* wrapper */
    .wrap{width:100%;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;gap:12px;padding:24px 12px}

    /* book shell keeps fixed aspect so images won't shift layout */
    .book-shell{width:100%;max-width:calc(var(--book-width));aspect-ratio:3/2;position:relative;perspective:2600px;display:flex;align-items:center;justify-content:center}

    /* main book */
    .book{width:100%;height:100%;position:relative;transform-style:preserve-3d;display:flex;background:linear-gradient(180deg,#fff,#f7f7f9);border-radius:12px;box-shadow:0 12px 40px rgba(12,20,30,0.12);overflow:hidden;z-index:20}

    /* left/right pages */
    .page-left,.page-right{width:50%;height:100%;position:relative;overflow:hidden;display:flex;align-items:center;justify-content:center;user-select:none}
    .page-left{border-right:1px solid rgba(0,0,0,.06);background:#fff}
    .page-right{background:#fff}

    /* dim placeholder */
    .page-left.is-blank img{opacity:.34;transform:scale(.98);filter:grayscale(.0)}

    /* images */
    .page-img{width:100%;height:100%;object-fit:contain;display:block;visibility:visible;min-width:120px;min-height:60px}

    /* flipper - the turning page */
    .flipper{position:absolute;top:0;left:50%;width:50%;height:100%;transform-origin:left center;pointer-events:none;z-index:70;will-change:transform,filter;transform-style:preserve-3d}
    .flipper .face{position:absolute;inset:0;backface-visibility:hidden;background:#fff;display:flex;align-items:center;justify-content:center;overflow:hidden}
    .flipper .face img{width:100%;height:100%;object-fit:contain}
    .flipper.hidden{display:none}

    /* faces decoration */
    .flipper .face::after{content:'';position:absolute;top:0;right:0;width:4px;height:100%;background:linear-gradient(90deg,rgba(255,255,255,.95),rgba(255,255,255,.25));transform:translateX(50%);pointer-events:none}
    .flipper .back{transform:rotateY(180deg);background:linear-gradient(180deg,#f6f6f6,#efefef)}

    /* underlay - shows incoming page behind the flipper */
    .underlay{position:absolute;top:0;left:50%;width:50%;height:100%;pointer-events:none;z-index:40;display:flex;align-items:center;justify-content:center;opacity:0;transition:opacity .18s ease, transform .18s ease, filter .18s ease;overflow:hidden}
    .underlay img{width:100%;height:100%;object-fit:contain;display:block}
    .underlay.show{opacity:1;transform:translateZ(6px) scale(1.01);filter:blur(.2px)}
    @media (max-width:720px){ .underlay{left:0;width:100%} }

    /* subtle shadows */
    .page-shadow{position:absolute;inset:0;pointer-events:none;z-index:5}

    /* controls - absolutely positioned relative to book-shell so it's always centered below the book */
    .controls{display:flex;gap:10px;align-items:center;justify-content:center;width:auto;box-sizing:border-box;padding:8px 12px;position:absolute;left:50%;transform:translateX(-50%);bottom:-72px;z-index:90;background:transparent}
    button{padding:8px 14px;border-radius:8px;border:1px solid rgba(0,0,0,.08);background:#fff;cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    .info{font-size:14px;color:#444;text-align:center;min-width:120px}
    .tips{font-size:13px;color:#666;max-width:900px;text-align:center;margin-top:6px;position:relative;z-index:5}

    /* responsive small screens */
    @media (max-width:720px){:root{--book-width:360px;--book-height:520px}.book{flex-direction:column}.page-left,.page-right{width:100%;height:50%}.flipper{left:0;width:100%;transform-origin:center center}.controls{position:static;transform:none;margin-top:8px;bottom:auto}.underlay{left:0;width:100%}}

    /* helper classes for interactive state */
    .dragging { cursor:grabbing }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="book-shell" id="bookShell">
      <div class="book" id="book">
        <div class="page-left" id="leftPage"><img class="page-img" id="leftImg" src="" alt="Left page"/></div>
        <div class="page-right" id="rightPage"><img class="page-img" id="rightImg" src="" alt="Right page"/></div>

        <div class="flipper hidden" id="flipper" aria-hidden="true">
          <div class="face front"><img id="flipFront" src="" alt="flip front"/></div>
          <div class="face back"><img id="flipBack" src="" alt="flip back"/></div>
        </div>

        <div class="underlay" id="underlay" aria-hidden="true"><img src="" alt="underlay"/></div>
      </div>

      <div class="controls">
        <button id="prevBtn">◀ Prev</button>
        <div class="info" id="pageInfo">Page 1 / 1</div>
        <button id="nextBtn">Next ▶</button>
      </div>
    </div>

    <div class="tips">Tips: drag the right page left to turn forward, drag the left page right to go back. Click for instant turn.</div>
  </div>

  <script>
    // ========== CONFIG ==========
    const pages = [
      'images/page1.jpg',
      'images/page2.jpg',
      'images/page3.jpg',
      'images/page4.jpg',
      'images/page5.jpg',
      'images/page6.jpg',
      'images/page9.jpg',
      'images/page10.jpg',
      'images/page11.jpg',
      'images/page12.jpg',
      'images/page13.jpg',
      'images/page14.jpg',
    ];
    // ============================

    // DOM
    const leftPageEl = document.getElementById('leftPage');
    const leftImg = document.getElementById('leftImg');
    const rightImg = document.getElementById('rightImg');
    const flipFront = document.getElementById('flipFront');
    const flipBack = document.getElementById('flipBack');
    const flipper = document.getElementById('flipper');
    const underlay = document.getElementById('underlay');
    const book = document.getElementById('book');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const pageInfo = document.getElementById('pageInfo');
    const bookShell = document.getElementById('bookShell');

    let currentRightIndex = 0;

    // preload
    const preloaded = []; let loadedCount = 0;
    function preloadAll(){
      pages.forEach((p,i)=>{
        const img = new Image(); img.src = p; img.onload = ()=>{loadedCount++;}; img.onerror=()=>{loadedCount++;}; preloaded[i]=img;
      });
    }
    preloadAll();

    function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

    function updateView(){
      const leftIndex = currentRightIndex - 1;
      if(leftIndex >= 0 && pages[leftIndex]){ leftPageEl.classList.remove('is-blank'); leftImg.src = pages[leftIndex]; }
      else { leftPageEl.classList.add('is-blank'); leftImg.src = pages[currentRightIndex] || ''; }
      rightImg.src = pages[currentRightIndex] || '';
      prevBtn.disabled = currentRightIndex <= 0;
      nextBtn.disabled = currentRightIndex >= pages.length - 1;
      const humanLeft = leftIndex >= 0 ? leftIndex + 1 : '-';
      const humanRight = currentRightIndex + 1;
      pageInfo.textContent = `Pages ${humanLeft} — ${humanRight} / ${pages.length}`;
    }

    updateView();

    // ---------- Interactive Drag Flip ----------
    let pointerDown = false;
    let isDragging = false;
    let startX = 0;
    let direction = null; // 'next' or 'prev'
    let animFrame = null;
    let progress = 0; // 0..1
    const maxAngle = 180; // degrees

    function showFlipper(){ flipper.classList.remove('hidden'); underlay.classList.add('show'); }
    function hideFlipper(){ flipper.classList.add('hidden'); underlay.classList.remove('show'); }

    function setFlipperImages(forDir){
      if(forDir === 'next'){
        flipFront.src = pages[currentRightIndex] || '';
        flipBack.src = pages[currentRightIndex + 1] || '';
        underlay.querySelector('img').src = pages[currentRightIndex + 1] || '';
      } else {
        const leftIndex = currentRightIndex - 1;
        flipFront.src = pages[leftIndex] || pages[currentRightIndex] || '';
        flipBack.src = pages[currentRightIndex] || '';
        underlay.querySelector('img').src = pages[leftIndex] || '';
      }
    }

    function applyProgress(p){
      progress = clamp(p,0,1);
      const eased = Math.sin(progress * Math.PI * 0.5); // easeOutSine
      const angle = -maxAngle * eased * (direction === 'prev' ? -1 : 1);
      const translateX = (direction === 'next') ? (-progress * 8) : (progress * 8);
      const skew = (direction === 'next') ? (-progress * 3) : (progress * 3);
      const z = 12 * eased;
      const rot = `rotateY(${angle}deg)`;
      flipper.style.transform = `translateZ(${z}px) translateX(${translateX}%) ${rot} skewY(${skew}deg)`;
      const backfaceOpacity = Math.min(1, Math.max(0, (progress - 0.4) * 2.0));
      const backEl = flipper.querySelector('.back'); if(backEl) backEl.style.opacity = backfaceOpacity;
      underlay.style.transform = `translateZ(${z/1.5}px) scale(${1 + progress*0.015})`;
      underlay.style.filter = `blur(${0.2 * progress}px)`;
      book.style.boxShadow = `0 ${12 + 20*progress}px ${40 + 40*progress}px rgba(12,20,30,${0.12 + 0.12*progress})`;
    }

    function animateTo(target, duration = 360){
      const start = performance.now();
      const from = progress;
      const to = clamp(target,0,1);
      if(animFrame) cancelAnimationFrame(animFrame);
      function step(now){
        const t = clamp((now - start) / duration, 0, 1);
        const ease = t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
        const value = from + (to - from) * ease;
        applyProgress(value);
        if(t < 1) animFrame = requestAnimationFrame(step);
        else {
          if(to === 1){
            if(direction === 'next') currentRightIndex = clamp(currentRightIndex + 1, 0, pages.length - 1);
            else if(direction === 'prev') currentRightIndex = clamp(currentRightIndex - 1, 0, pages.length - 1);
            applyProgress(0);
            hideFlipper();
            updateView();
          } else {
            applyProgress(0);
            hideFlipper();
            updateView();
          }
          pointerDown = false; isDragging = false;
          animFrame = null;
          document.body.classList.remove('dragging');
        }
      }
      animFrame = requestAnimationFrame(step);
    }

    // pointer handlers
    function onPointerDown(e){
      if(animFrame) return;
      const rect = book.getBoundingClientRect();
      startX = (e.touches ? e.touches[0].clientX : e.clientX);
      const relX = startX - rect.left;
      const half = rect.width / 2;
      if(relX > half * 0.55){ direction = 'next'; }
      else if(relX < half * 0.45){ direction = 'prev'; }
      else { direction = null; }
      if(!direction) return;
      pointerDown = true; isDragging = false;
      document.body.classList.add('dragging');
      setFlipperImages(direction);
      showFlipper();
      applyProgress(0);
      window.addEventListener('pointermove', onPointerMove);
      window.addEventListener('pointerup', onPointerUp);
      window.addEventListener('pointercancel', onPointerUp);
      if(e.target.setPointerCapture) try{ e.target.setPointerCapture(e.pointerId); } catch(err){}
    }

    function onPointerMove(e){
      if(!pointerDown) return;
      const x = (e.touches ? e.touches[0].clientX : e.clientX);
      const rect = book.getBoundingClientRect();
      const half = rect.width / 2;
      let delta = 0;
      if(direction === 'next'){ delta = (startX - x); }
      else { delta = (x - startX); }
      if(!isDragging){ if(Math.abs(delta) > 6) isDragging = true; else return; }
      const p = clamp(delta / (half), 0, 1);
      applyProgress(p);
    }

    function onPointerUp(e){
      if(!pointerDown) return;
      // if user didn't actually drag (a click), treat as click: complete full flip
      if(!isDragging){ animateTo(1,360); return; }
      const completionThreshold = 0.45;
      const shouldComplete = progress > completionThreshold;
      if(shouldComplete) animateTo(1,360);
      else animateTo(0,280);
      window.removeEventListener('pointermove', onPointerMove);
      window.removeEventListener('pointerup', onPointerUp);
      window.removeEventListener('pointercancel', onPointerUp);
    }

    // attach events
    rightImg.addEventListener('pointerdown', onPointerDown);
    leftImg.addEventListener('pointerdown', onPointerDown);

    // click handlers for buttons (instant flip)
    nextBtn.addEventListener('click', ()=>{
      if(currentRightIndex < pages.length-1 && !pointerDown){
        direction='next'; setFlipperImages('next'); showFlipper(); animateTo(1,380);
      }
    });
    prevBtn.addEventListener('click', ()=>{
      if(currentRightIndex>0 && !pointerDown){
        direction='prev'; setFlipperImages('prev'); showFlipper(); animateTo(1,380);
      }
    });

    // click on pages: trigger animated flip to corresponding direction (only if not dragging)
    document.getElementById('rightPage').addEventListener('click',(e)=>{
      if(isDragging) return;
      if(currentRightIndex < pages.length-1){ direction='next'; setFlipperImages('next'); showFlipper(); animateTo(1,380); }
    });
    document.getElementById('leftPage').addEventListener('click',(e)=>{
      if(isDragging) return;
      if(currentRightIndex > 0){ direction='prev'; setFlipperImages('prev'); showFlipper(); animateTo(1,380); }
    });

    // keyboard
    document.addEventListener('keydown',(e)=>{ if(e.key==='ArrowRight'){ nextBtn.click(); } if(e.key==='ArrowLeft'){ prevBtn.click(); } });

    // touch support
    book.addEventListener('touchstart',(e)=>{ onPointerDown(e); }, {passive:false});

    // ensure page clicks still work when not dragging
    document.getElementById('rightPage').addEventListener('click',()=>{});
    document.getElementById('leftPage').addEventListener('click',()=>{});

    // expose debug
    window._book = { pages, setPage(i){ currentRightIndex = clamp(i,0,pages.length-1); updateView(); } };
  </script>
</body>
</html>
