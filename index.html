<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Book Flip — Realistic Covering Flip</title>
<style>
  :root{ --book-width:900px; --book-height:600px; }
  *{box-sizing:border-box; user-select:none;}
  body{ margin:0; min-height:100vh; display:flex; align-items:center; justify-content:center; flex-direction:column; background:#eee; font-family:Arial, sans-serif; }

  /* BOOK LAYOUT -------------------------------------------------- */
  .book{
    width:var(--book-width);
    height:var(--book-height);
    display:flex;
    position:relative;
    box-shadow:0 18px 50px rgba(0,0,0,0.15);
  }

  .left-page{
    width:50%;
    height:100%;
    background:#fff;
    overflow:hidden;
    position:relative;
    z-index:1;
  }

  .left-page img{ width:100%; height:100%; object-fit:cover; display:block; }

  /* left cover (growing overlay from right to left) */
  #leftCover{
    position:absolute;
    top:0;
    right:0;
    height:100%;
    width:0%;
    background-position:right center;
    background-size:cover;
    pointer-events:none;
    z-index:5;
    box-shadow: inset -40px 0 60px rgba(0,0,0,0.35);
  }

  .right-stack{
    width:50%;
    height:100%;
    position:relative;
    perspective:2000px;
    overflow:visible;
  }

  /* sheet that rotates */
  .sheet{
    width:100%;
    height:100%;
    position:absolute;
    top:0;
    left:0;
    transform-style:preserve-3d;
    transform-origin:left center;
    z-index:50;
    will-change:transform, box-shadow;
  }

  .face{
    width:100%;
    height:100%;
    position:absolute;
    backface-visibility:hidden;
    overflow:hidden;
    background:#fff;
  }

  .face img{ width:100%; height:100%; object-fit:cover; display:block; }

  .back{ transform:rotateY(180deg); }

  /* simple controls */
  .controls{ margin-top:18px; display:flex; gap:12px; }
  button{ padding:8px 14px; border-radius:8px; border:1px solid #999; background:white; cursor:pointer; }
  button:disabled{ opacity:0.45; cursor:default; }
</style>
</head>
<body>

<div class="book" id="book">
  <div class="left-page" id="leftPage">
    <img id="leftImg" src="" alt="">
    <div id="leftCover"></div>
  </div>

  <div class="right-stack" id="rightStack"></div>
</div>

<div class="controls">
  <button id="prevBtn">◀ Prev</button>
  <button id="nextBtn">Next ▶</button>
</div>

<script>
/* =======================
   CONFIG: page images (reading order)
   Put files in images/ folder or change paths here
   ======================= */
const pages = [
  "images/page1.jpg",
  "images/page2.jpg",
  "images/page3.jpg",
  "images/page4.jpg",
  "images/page5.jpg",
  "images/page6.jpg"
];
/* ======================= */

/* Build spreads (pairs) */
const spreads = [];
for (let i = 0; i < pages.length; i += 2) {
  spreads.push({ left: pages[i] || '', right: pages[i+1] || '' });
}

const leftImg = document.getElementById('leftImg');
const leftCover = document.getElementById('leftCover');
const rightStack = document.getElementById('rightStack');
const nextBtn = document.getElementById('nextBtn');
const prevBtn = document.getElementById('prevBtn');
const book = document.getElementById('book');

let flipped = 0;         // how many sheets are flipped (0..spreads.length)
let isAnimating = false; // guard

/* Create sheets on right side (one per spread).
   Each sheet has front = right-page, back = left-page.
   The visual flip will rotate this sheet from 0 to -180deg.
*/
spreads.forEach((sp, idx) => {
  const sheet = document.createElement('div');
  sheet.className = 'sheet';
  sheet.dataset.index = idx;
  sheet.style.zIndex = 200 - idx;

  const front = document.createElement('div');
  front.className = 'face front';
  if (sp.right) front.innerHTML = `<img src="${sp.right}" alt="p${idx*2+2}">`;

  const back = document.createElement('div');
  back.className = 'face back';
  if (sp.left) back.innerHTML = `<img src="${sp.left}" alt="p${idx*2+1}">`;

  sheet.appendChild(front);
  sheet.appendChild(back);
  rightStack.appendChild(sheet);
});

/* Initialize left image */
leftImg.src = spreads[0] ? spreads[0].left : '';
leftCover.style.width = '0%';

/* Utility: easing cubic-bezier approx (easeOutQuad) */
function easeOutQuad(t){ return 1 - (1 - t) * (1 - t); }

/* Animate flip with requestAnimationFrame so we can update leftCover width and sheet shadow */
function animateFlip(sheet, direction = 'next', duration = 900){
  // direction: 'next' means rotate from 0 -> -180
  // 'prev' means rotate from -180 -> 0
  if (isAnimating) return Promise.reject('animating');

  isAnimating = true;
  setControls(false);

  const start = performance.now();
  const from = (direction === 'next') ? 0 : -180;
  const to = (direction === 'next') ? -180 : 0;

  // For leftCover we want progress 0->1 where 0 no cover, 1 full cover
  // For next: progress = t, for prev: progress = t reversed
  return new Promise((resolve) => {
    function frame(now){
      let t = Math.min(1, (now - start) / duration);
      const eased = easeOutQuad(t);
      const angle = from + (to - from) * eased;

      // apply rotation (around left center)
      sheet.style.transform = `rotateY(${angle}deg)`;

      // compute cover progress: when angle moves from 0 to -90 the sheet starts covering,
      // after -90 it recedes visually but we still keep coverage until end.
      // We'll map eased progress to cover width linear 0..100%.
      const coverProgress = (direction === 'next') ? eased : (1 - eased);
      const coverPct = Math.round(coverProgress * 100);

      // Set leftCover to show the same image as the sheet front (so it looks like sheet is covering)
      const frontImg = sheet.querySelector('.face.front img');
      const frontSrc = frontImg ? frontImg.src : '';
      if (frontSrc) {
        leftCover.style.backgroundImage = `url("${frontSrc}")`;
        leftCover.style.backgroundPosition = 'right center';
        leftCover.style.backgroundSize = 'cover';
      } else {
        leftCover.style.backgroundImage = '';
      }

      // grow/shrink leftCover width from 0 -> 100% (right aligned)
      leftCover.style.width = `${coverPct}%`;

      // dynamic shadow on sheet for depth
      // stronger shadow around mid-flip
      const shadowStrength = 0.25 + 0.45 * Math.sin(Math.PI * eased);
      sheet.style.boxShadow = `-20px 8px 70px rgba(0,0,0,${shadowStrength})`;

      if (t < 1) {
        requestAnimationFrame(frame);
      } else {
        // finalize: ensure final transform & cover states
        sheet.style.transform = `rotateY(${to}deg)`;
        leftCover.style.width = (direction === 'next') ? '100%' : '0%';
        sheet.style.boxShadow = '';

        // done
        isAnimating = false;
        setControls(true);
        resolve();
      }
    }
    requestAnimationFrame(frame);
  });
}

/* Flip next: animate sheet index = flipped (0-based) from 0->-180.
   After animation ends, increment flipped and update left image to new spreads[flipped].left
   Then clear leftCover (so underlying leftImg becomes visible)
*/
async function goNext(){
  if (isAnimating) return;
  if (flipped >= spreads.length - 1) return;

  const sheet = rightStack.querySelector(`.sheet[data-index="${flipped}"]`);
  if (!sheet) return;

  // Preload the new left image to avoid flash
  const upcomingLeft = spreads[flipped + 1] ? spreads[flipped + 1].left : '';
  if (upcomingLeft) {
    const img = new Image();
    img.src = upcomingLeft;
  }

  // animate
  await animateFlip(sheet, 'next', 900);

  // after animation: flip state, update leftImg to new left page, clear leftCover
  flipped++;
  leftImg.src = spreads[flipped] ? spreads[flipped].left : '';
  // small timeout to let paint happen before hiding cover
  setTimeout(() => leftCover.style.width = '0%', 40);
}

/* Flip prev: animate sheet index = flipped-1 from -180->0.
   Before animation we set leftCover to show the sheet front (which is the right page of that sheet),
   but because animateFlip handles cover we just call it.
   After animation ends we decrement flipped and update leftImg.
*/
async function goPrev(){
  if (isAnimating) return;
  if (flipped <= 0) return;

  const idx = flipped - 1;
  const sheet = rightStack.querySelector(`.sheet[data-index="${idx}"]`);
  if (!sheet) return;

  // Preload the left that will become visible (spreads[idx].left)
  const upcomingLeft = spreads[idx] ? spreads[idx].left : '';
  if (upcomingLeft) {
    const img = new Image();
    img.src = upcomingLeft;
  }

  // animate unflip
  await animateFlip(sheet, 'prev', 900);

  // after animation: decrement flipped, update left image
  flipped--;
  leftImg.src = spreads[flipped] ? spreads[flipped].left : '';
  // ensure cover gone
  leftCover.style.width = '0%';
}

/* Controls enable/disable */
function setControls(enabled){
  nextBtn.disabled = !enabled || (flipped >= spreads.length - 1);
  prevBtn.disabled = !enabled || (flipped <= 0);
}

/* Event handlers */
nextBtn.addEventListener('click', goNext);
prevBtn.addEventListener('click', goPrev);

book.addEventListener('click', (e) => {
  if (isAnimating) return;
  const rect = book.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  if (clickX > rect.width / 2) goNext(); else goPrev();
});

// keyboard
document.addEventListener('keydown', (e) => {
  if (isAnimating) return;
  if (e.key === 'ArrowRight') goNext();
  if (e.key === 'ArrowLeft') goPrev();
});

// swipe
let startX = null;
book.addEventListener('touchstart', (e) => { if (e.touches && e.touches.length === 1) startX = e.touches[0].clientX; }, {passive:true});
book.addEventListener('touchend', (e) => {
  if (startX === null) return;
  const dx = e.changedTouches[0].clientX - startX;
  startX = null;
  if (Math.abs(dx) < 30) return;
  if (dx < 0) goNext(); else goPrev();
});

/* Init controls */
setControls(true);
</script>

</body>
</html>
